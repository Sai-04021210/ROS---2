#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from std_msgs.msg import Float64MultiArray
from visualization_msgs.msg import Marker, MarkerArray
from geometry_msgs.msg import Point
from rclpy.callback_groups import ReentrantCallbackGroup
from rclpy.executors import MultiThreadedExecutor
import numpy as np
import time

class LegoPickPlace(Node):
    """
    A node for picking and placing LEGO bricks.

    This node provides predefined pick and place operations for LEGO bricks
    without using camera-based perception.
    """

    def __init__(self):
        super().__init__('lego_pick_place')

        # Create callback group for reentrant callbacks
        self.callback_group = ReentrantCallbackGroup()

        # Create publisher for joint commands
        self.joint_cmd_pub = self.create_publisher(
            Float64MultiArray,
            '/joint_commands',
            10
        )

        # Create publisher for visualization markers
        self.marker_pub = self.create_publisher(
            MarkerArray,
            '/visualization_markers',
            10
        )

        # Define predefined brick positions
        self.brick_positions = {
            'brick_2x4_red': [0.1, 0.1, 0.01],
            'brick_2x2_blue': [-0.1, 0.1, 0.01],
            'brick_1x2_green': [0, -0.1, 0.01]
        }

        # Define target positions
        self.target_positions = {
            'target_1': [0.15, -0.15, 0.01],
            'target_2': [-0.15, -0.15, 0.01]
        }

        # Define joint configurations for picking positions
        self.pick_joint_configs = {
            'brick_2x4_red': [0.3, 0.2, -0.1, -0.5],  # [base, arm1, arm2, gripper]
            'brick_2x2_blue': [-0.3, 0.2, -0.1, -0.5],
            'brick_1x2_green': [0.0, 0.3, -0.1, -0.5]
        }

        # Define joint configurations for placing positions
        self.place_joint_configs = {
            'target_1': [0.5, 0.2, -0.1, -0.5],
            'target_2': [-0.5, 0.2, -0.1, -0.5]
        }

        # Home position
        self.home_position = [0.0, 0.0, 0.0, -0.5]  # Gripper open

        # Create a timer for demo sequence
        self.demo_timer = self.create_timer(
            5.0,  # Start demo after 5 seconds
            self.run_demo,
            callback_group=self.callback_group
        )
        self.demo_timer.cancel()  # Don't start automatically

        # Publish initial markers
        self.publish_markers()

        self.get_logger().info('LEGO pick and place node initialized')

    def publish_markers(self):
        """Publish visualization markers for bricks and targets."""
        marker_array = MarkerArray()
        marker_id = 0

        # Brick markers
        for brick_name, position in self.brick_positions.items():
            marker = Marker()
            marker.header.frame_id = "world"
            marker.header.stamp = self.get_clock().now().to_msg()
            marker.ns = "bricks"
            marker.id = marker_id
            marker_id += 1
            marker.type = Marker.CUBE
            marker.action = Marker.ADD

            # Set position
            marker.pose.position.x = float(position[0])
            marker.pose.position.y = float(position[1])
            marker.pose.position.z = float(position[2])

            # Set orientation (identity quaternion)
            marker.pose.orientation.w = 1.0

            # Set scale based on brick type
            if "2x4" in brick_name:
                marker.scale.x = 0.032  # 4 * lego_unit
                marker.scale.y = 0.016  # 2 * lego_unit
                marker.scale.z = 0.0096  # lego_height
                marker.color.r = 1.0
            elif "2x2" in brick_name:
                marker.scale.x = 0.016  # 2 * lego_unit
                marker.scale.y = 0.016  # 2 * lego_unit
                marker.scale.z = 0.0096  # lego_height
                marker.color.b = 1.0
            elif "1x2" in brick_name:
                marker.scale.x = 0.016  # 2 * lego_unit
                marker.scale.y = 0.008  # 1 * lego_unit
                marker.scale.z = 0.0096  # lego_height
                marker.color.g = 1.0

            marker.color.a = 1.0
            marker_array.markers.append(marker)

        # Target markers
        for target_name, position in self.target_positions.items():
            marker = Marker()
            marker.header.frame_id = "world"
            marker.header.stamp = self.get_clock().now().to_msg()
            marker.ns = "targets"
            marker.id = marker_id
            marker_id += 1
            marker.type = Marker.CYLINDER
            marker.action = Marker.ADD

            # Set position
            marker.pose.position.x = float(position[0])
            marker.pose.position.y = float(position[1])
            marker.pose.position.z = float(position[2])

            # Set orientation (identity quaternion)
            marker.pose.orientation.w = 1.0

            # Set scale
            marker.scale.x = 0.05
            marker.scale.y = 0.05
            marker.scale.z = 0.001

            # Set color (semi-transparent yellow)
            marker.color.r = 1.0
            marker.color.g = 1.0
            marker.color.b = 0.0
            marker.color.a = 0.5

            marker_array.markers.append(marker)

        self.marker_pub.publish(marker_array)

    def publish_joint_command(self, positions):
        """Publish joint commands."""
        msg = Float64MultiArray()
        msg.data = positions
        self.joint_cmd_pub.publish(msg)
        time.sleep(2.0)  # Simple wait for motion to complete

    def pick_brick(self, brick_name):
        """
        Pick a brick by name.

        Args:
            brick_name: Name of the brick to pick
        """
        if brick_name not in self.pick_joint_configs:
            self.get_logger().error(f'Unknown brick: {brick_name}')
            return False

        # Move to pre-grasp position with open gripper
        joint_config = self.pick_joint_configs[brick_name].copy()
        joint_config[3] = -0.5  # Open gripper
        self.publish_joint_command(joint_config)

        # Close gripper to grasp
        joint_config[3] = -0.05  # Close gripper
        self.publish_joint_command(joint_config)

        # Lift slightly
        joint_config[1] -= 0.1  # Lift arm
        self.publish_joint_command(joint_config)

        return True

    def place_brick(self, target_name):
        """
        Place a brick at the target position.

        Args:
            target_name: Name of the target position
        """
        if target_name not in self.place_joint_configs:
            self.get_logger().error(f'Unknown target: {target_name}')
            return False

        # Move to pre-place position
        joint_config = self.place_joint_configs[target_name].copy()
        self.publish_joint_command(joint_config)

        # Open gripper to release
        joint_config[3] = -0.5  # Open gripper
        self.publish_joint_command(joint_config)

        # Move up slightly
        joint_config[1] -= 0.1  # Lift arm
        self.publish_joint_command(joint_config)

        return True

    def move_to_home(self):
        """Move the robot to home position."""
        self.publish_joint_command(self.home_position)
        return True

    def run_demo(self):
        """Run a demo sequence of pick and place operations."""
        self.get_logger().info('Starting demo sequence')

        # Move to home position
        self.move_to_home()

        # Pick and place the red 2x4 brick
        self.get_logger().info('Picking red 2x4 brick')
        self.pick_brick('brick_2x4_red')

        self.get_logger().info('Placing at target 1')
        self.place_brick('target_1')

        # Pick and place the blue 2x2 brick
        self.get_logger().info('Picking blue 2x2 brick')
        self.pick_brick('brick_2x2_blue')

        self.get_logger().info('Placing at target 2')
        self.place_brick('target_2')

        # Pick and place the green 1x2 brick
        self.get_logger().info('Picking green 1x2 brick')
        self.pick_brick('brick_1x2_green')

        self.get_logger().info('Placing at target 1 (stacking)')
        self.place_brick('target_1')

        # Return to home position
        self.move_to_home()

        self.get_logger().info('Demo sequence completed')

    def start_demo(self):
        """Start the demo sequence."""
        self.demo_timer.reset()

def main(args=None):
    rclpy.init(args=args)

    lego_pick_place = LegoPickPlace()

    # Use a multithreaded executor
    executor = MultiThreadedExecutor()
    executor.add_node(lego_pick_place)

    # Start the demo
    lego_pick_place.start_demo()

    try:
        executor.spin()
    except KeyboardInterrupt:
        pass
    finally:
        executor.shutdown()
        lego_pick_place.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
