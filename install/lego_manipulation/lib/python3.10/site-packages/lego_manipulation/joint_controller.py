#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from std_msgs.msg import Float64MultiArray
from sensor_msgs.msg import JointState
from rclpy.callback_groups import ReentrantCallbackGroup
from rclpy.executors import MultiThreadedExecutor
import numpy as np
import time

class JointController(Node):
    """
    A simple joint controller for the robot arm.
    
    This controller subscribes to joint state messages and publishes
    joint commands to control the robot arm.
    """
    
    def __init__(self):
        super().__init__('joint_controller')
        
        # Create callback group for reentrant callbacks
        self.callback_group = ReentrantCallbackGroup()
        
        # Create publishers for joint commands
        self.joint_cmd_pub = self.create_publisher(
            Float64MultiArray, 
            '/joint_commands', 
            10
        )
        
        # Subscribe to joint states
        self.joint_state_sub = self.create_subscription(
            JointState,
            '/joint_states',
            self.joint_state_callback,
            10,
            callback_group=self.callback_group
        )
        
        # Store current joint states
        self.current_joint_positions = None
        self.joint_names = [
            'baseplate_joint',
            'forward_drivearm_joint',
            'horizontal_arm_joint',
            'gripper_right_joint'
        ]
        
        # Initialize with home position
        self.home_position = [0.0, 0.0, 0.0, 0.0]
        
        self.get_logger().info('Joint controller initialized')
    
    def joint_state_callback(self, msg):
        """Callback for joint state messages."""
        # Extract joint positions for our controlled joints
        positions = []
        for joint_name in self.joint_names:
            if joint_name in msg.name:
                idx = msg.name.index(joint_name)
                positions.append(msg.position[idx])
            else:
                positions.append(0.0)
        
        self.current_joint_positions = positions
    
    def move_joints(self, target_positions, duration=2.0):
        """
        Move joints to target positions.
        
        Args:
            target_positions: List of target joint positions
            duration: Time to complete the motion in seconds
        """
        if self.current_joint_positions is None:
            self.get_logger().warn('No joint states received yet')
            return False
        
        start_positions = self.current_joint_positions.copy()
        start_time = time.time()
        rate = self.create_rate(50)  # 50 Hz control rate
        
        while rclpy.ok():
            elapsed = time.time() - start_time
            if elapsed >= duration:
                # Motion complete
                self.publish_joint_command(target_positions)
                break
            
            # Linear interpolation
            t = elapsed / duration
            current_targets = [
                start_pos + t * (target_pos - start_pos)
                for start_pos, target_pos in zip(start_positions, target_positions)
            ]
            
            self.publish_joint_command(current_targets)
            rate.sleep()
        
        return True
    
    def publish_joint_command(self, positions):
        """Publish joint commands."""
        msg = Float64MultiArray()
        msg.data = positions
        self.joint_cmd_pub.publish(msg)
    
    def move_to_home(self):
        """Move the robot to home position."""
        return self.move_joints(self.home_position)
    
    def open_gripper(self):
        """Open the gripper."""
        if self.current_joint_positions is None:
            return False
        
        target = self.current_joint_positions.copy()
        target[3] = -0.5  # Open position for gripper_right_joint
        return self.move_joints(target, duration=1.0)
    
    def close_gripper(self):
        """Close the gripper."""
        if self.current_joint_positions is None:
            return False
        
        target = self.current_joint_positions.copy()
        target[3] = -0.05  # Closed position for gripper_right_joint
        return self.move_joints(target, duration=1.0)

def main(args=None):
    rclpy.init(args=args)
    
    joint_controller = JointController()
    
    # Use a multithreaded executor
    executor = MultiThreadedExecutor()
    executor.add_node(joint_controller)
    
    try:
        executor.spin()
    except KeyboardInterrupt:
        pass
    finally:
        executor.shutdown()
        joint_controller.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
